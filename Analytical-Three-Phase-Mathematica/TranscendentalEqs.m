(* ::Package:: *)

(* ::Input:: *)
(*(* Properties of liquid and vapor phases*)*)
(**)
(*ClearAll["Global`*"]*)
(**)
(*cps=910;*)
(*ks=211;*)
(*\[Rho]s=2698.72;*)
(*\[Alpha]s = ks/(\[Rho]s*cps);*)
(*T0 = 298;*)
(*Tm=933.6;*)
(*Lm=383840;*)
(**)
(*kl=91.0;*)
(*cpl=1042.4;*)
(*\[Rho]l=2368;*)
(*\[Alpha]l=kl/(\[Rho]l*cpl);*)
(*Le=9462849.518;*)
(*Te=2767; (*Boiling point temperature*)*)
(**)
(**)
(*cpv=770.69;*)
(*kv=115.739;*)
(*\[Rho]v=0.08644;*)
(*\[Alpha]v=kv/(\[Rho]v*cpv);*)
(*T\[Infinity]=5000;*)
(**)
(*Tref = Tm;*)
(**)
(*C1 = Sqrt[\[Alpha]l /\[Alpha]s]*(\[Rho]l/\[Rho]s-\[Rho]v/\[Rho]s);*)
(*C2 =(1-\[Rho]l/\[Rho]s);*)
(*C3 = (1-\[Rho]v/\[Rho]l);*)
(**)
(*A1 = (Tm - T0)/Erfc[\[Beta] - \[Lambda]*C1-\[Beta]*C2];*)
(**)
(*A2 = (Tm - Te)/(Erf[\[Beta]*Sqrt[\[Alpha]s /\[Alpha]l]-\[Lambda]*C3]-Erf[\[Lambda] - \[Lambda]*C3]);*)
(*A3 = (Te -T\[Infinity] )/Erf[\[Lambda]*Sqrt[\[Alpha]l /\[Alpha]v]];*)
(*Eq1 = \[Rho]v*((cpv - cpl)*(Te - Tref)+Le)*\[Lambda]*Sqrt[\[Alpha]l ]+(kv*A3)/Sqrt[\[Pi]*\[Alpha]v]*Exp[-((\[Alpha]l*\[Lambda]^2)/\[Alpha]v)]-(kl*A2)/Sqrt[\[Pi]*\[Alpha]l]*Exp[-(\[Lambda]*(1-C3))^2];*)
(**)
(*Eq2 = (\[Rho]l*\[Beta]*Sqrt[\[Alpha]s ] - (\[Rho]l-\[Rho]v)*\[Lambda]*Sqrt[\[Alpha]l ])*((cpl - cps)*(Tm - Tref)+Lm)+(kl*A2)/Sqrt[\[Pi]*\[Alpha]l]*Exp[-(\[Beta]*Sqrt[\[Alpha]s /\[Alpha]l]-\[Lambda]*C3)^2]+(ks*A1)/Sqrt[\[Pi]*\[Alpha]s]*Exp[-(\[Beta]*(1-C2)-\[Lambda]*C1)^2];*)
(**)
(* soln = {\[Lambda],\[Beta]}/.FindRoot[{Eq1==0,Eq2==0},{{\[Lambda],0.01},{\[Beta],0.01}}]*)


(* ::Input:: *)
(*\[Lambda] = soln[ [1] ]*)
(*\[Beta] = soln[ [2] ]*)
(**)


(* ::Input:: *)
(**)
(**)
(*resEq1 = Eq1 (*Check the residual of Eq1 *)*)
(*resEq2 = Eq2 (*Check the residual of Eq2 *)*)


(* ::Input:: *)
(**)
(*(*Plot the interfaces *)*)
(*lsinterface[t_] = \[Beta]*2*Sqrt[\[Alpha]s *t ] ;*)
(*vlinterface[t_] = \[Lambda]*2*Sqrt[\[Alpha]l *t ] ;*)
(*Plot[{lsinterface[t],vlinterface[t]},{t,0,2},PlotLabels->"Expressions"]*)


(* ::Input:: *)
(**)
(**)
(*l0 = 10;  (*this is arbitrary*)*)
(*tf = 3.5; (*this is also arbitrary. The mass balance should be valid at all times*)*)
(*s2 = \[Lambda]*2*Sqrt[\[Alpha]l *tf  ]*)
(*s1 = \[Beta]*2*Sqrt[\[Alpha]s *tf  ] *)
(*mv = \[Rho]v*s2*)
(*ml = \[Rho]l*(s1 - s2)*)
(*ms = \[Rho]s*(l0-s1)*)
(**)
(*mi = \[Rho]s*l0*)
(**)
(*msout = (\[Rho]l-\[Rho]v)*s2 + (\[Rho]s-\[Rho]l)*s1*)
(*deltaM = mv+ml+ms + msout - mi *)


(* ::Input:: *)
(*NumberForm[deltaM,{1,15}]*)


(* ::Input:: *)
(**)
